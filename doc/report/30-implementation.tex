\section{Implementation}
\label{sec:implementation}
The program implemented to solve the Roommate Assignment problem uses both approaches -- with and without simulated annealing -- with the same generated incompatibility matrix. The problem is solved by a function named \texttt{distribute} that is included at two distinct points of the code with different preprocessor environments. This benefits debugging by reusing the common code of both approaches.

The number of students -- $n$ -- and the initial temperature -- $T_{0}$ -- are given as arguments. $n$ is used to allocate the global incompatibility matrix ($n^{2}$) and the room distribution vector ($n$), which is used by the \texttt{distribute} function to output the result. The program then proceeds in generating the values for the incompatibility matrix, and injects a perfect solution.

The \texttt{distribute} function starts by allocating an auxiliary vector, which is used to track the room assigned to each student (in contrast with the output vector that tracks the students assigned to each room). An initial student distribution is then randomly generated, and the current state cost is calculated. In the simulated annealing approach, the temperature is set to the given initial value at the end of this stage.

The iterative process to find a solution in the \texttt{distribute} function is limited by the number of stagnant iterations ($n^{2}$). In each iteration, two students in distinct rooms are randomly selected\footnote{Both rooms and students are identified by integer non-negative numbers. The former correspond to an index in the output vector, the latter to an index in the auxiliary vector.} and the cost of swapping them is calculated. If the cost of the swap is less than the current cost -- or, with simulated annealing, if the temperature is high enough for $e^{-\Delta/T}$ to exceed a randomly generated value -- the swap is accepted and the stagnant iterations counter is reset; otherwise, the state is not modified and the counter is incremented. With simulated annealing, the temperature is reduced at the end of each iteration using the cooling function $T_{i+1}=0.999\times T_{i}$.

One of the key points in this algorithm is precisely the condition of acceptance based on the \texttt{exp} function. This condition, meant to decide whether a worse state will be accepted or not, always causes a state with equal cost to be accepted. Despite not changing the cost, rearranging some students may unlock better combinations in the next iterations, which makes this a desirable feature. At the same time, in late stages of the execution, when the temperature is so low that only the better solutions are accepted, this may cause the algorithm to follow loops, constantly resetting the stagnant counter and extending the execution time beyond usable walltimes. To correct this, a second iteration counter is added, which is reset only when the cost is changed. While this new counter allows the algorithm to keep accepting states with the same cost, it forces the stop when too many iterations have passed with no improvements.

\input{report/31-parallelism.tex}